1
00:00:01,880 --> 00:00:02,480
同学们好

2
00:00:02,800 --> 00:00:05,480
欢迎来到java课程课时一

3
00:00:05,960 --> 00:00:07,120
对象和封装

4
00:00:07,740 --> 00:00:09,500
该课时呢有以下几个考点

5
00:00:09,890 --> 00:00:10,410
分别为

6
00:00:10,770 --> 00:00:13,490
掌握类和对象的概念和类图介绍

7
00:00:13,970 --> 00:00:15,810
掌握构造方法及其重载

8
00:00:16,050 --> 00:00:18,010
掌握封装的概念及其使用

9
00:00:18,790 --> 00:00:21,110
课时一呢虽然内容比较简单

10
00:00:21,920 --> 00:00:24,320
但是它是我们java这门课的基础

11
00:00:24,760 --> 00:00:27,440
在考试题中呢频繁出现

12
00:00:28,000 --> 00:00:30,520
比如说我们做一些程序阅读啊

13
00:00:31,160 --> 00:00:32,400
一些程序编写的题目

14
00:00:32,840 --> 00:00:35,440
它是离不开这个对象和封装这个概念

15
00:00:36,530 --> 00:00:37,730
那比如说选择填空

16
00:00:37,930 --> 00:00:39,250
也是离不开这个概念

17
00:00:39,370 --> 00:00:41,820
所以说基本上每道题

18
00:00:41,820 --> 00:00:45,260
他的可能都会掺杂着这个知识点去考

19
00:00:45,990 --> 00:00:47,790
跟着老师的这个节奏呢

20
00:00:48,030 --> 00:00:49,990
把那个课时的内容听懂

21
00:00:50,790 --> 00:00:53,590
并且呢老师也会梳理这个例题

22
00:00:54,070 --> 00:00:56,230
然后留给大家一些课后习题

23
00:00:56,230 --> 00:00:57,590
大家要积极去完成

24
00:00:58,240 --> 00:00:59,880
我们来看正式的内容

25
00:01:00,640 --> 00:01:02,520
现实世界是由什么组成的呢

26
00:01:03,360 --> 00:01:07,820
有各种东西飞机呀船啊动物啊

27
00:01:08,500 --> 00:01:10,220
很多东西组成了我们这个世

28
00:01:10,260 --> 00:01:11,620
界的一个整体

29
00:01:12,200 --> 00:01:14,000
我们一句话去概括一下是什么东西

30
00:01:14,000 --> 00:01:16,920
就是世界是由对象组成的

31
00:01:17,750 --> 00:01:20,110
那为什么去使用面向对象呢

32
00:01:20,990 --> 00:01:22,310
在回答这个问题之前呢

33
00:01:22,310 --> 00:01:23,430
我要给大家解释一下

34
00:01:23,430 --> 00:01:25,110
我们java是用来干什么

35
00:01:25,110 --> 00:01:26,950
java其实是软件语言

36
00:01:27,430 --> 00:01:29,870
那软件我们是做什么的软件

37
00:01:29,870 --> 00:01:30,830
出现的目的就是用

38
00:01:30,870 --> 00:01:33,350
计算机语言去解决一个现实的问题

39
00:01:33,670 --> 00:01:34,790
去描述现实世界

40
00:01:35,270 --> 00:01:37,230
那我们java这个面向对象的思想

41
00:01:37,230 --> 00:01:39,870
就是来描述面向对象的世界

42
00:01:40,450 --> 00:01:43,810
那这样更加符合我们人类的思维习惯

43
00:01:44,220 --> 00:01:46,500
也就是说我们这样去做的话

44
00:01:46,660 --> 00:01:48,860
我们面向对象去设计开发程序

45
00:01:48,860 --> 00:01:50,020
都是非常好的

46
00:01:50,430 --> 00:01:52,030
首先呢交流更加顺畅

47
00:01:52,510 --> 00:01:54,710
提高程序的设计和开发的效率

48
00:01:56,300 --> 00:01:58,020
看一下这个宠物图啊

49
00:01:58,340 --> 00:02:01,220
宠物呢我们有企鹅狗啊各种东西

50
00:02:01,340 --> 00:02:02,940
这一类宠物呢其实它就是

51
00:02:03,300 --> 00:02:04,420
现实世界的对象

52
00:02:04,820 --> 00:02:06,780
什么对象它是宠物类这个对象

53
00:02:07,560 --> 00:02:09,240
那如何在计算机中描述它们呢

54
00:02:09,639 --> 00:02:12,320
我们在现实世界中抽象出类

55
00:02:12,480 --> 00:02:13,400
其实分为三步

56
00:02:13,400 --> 00:02:14,720
我刚才说它是宠物类

57
00:02:15,440 --> 00:02:16,280
如何把这个类

58
00:02:16,480 --> 00:02:18,200
从现实世界中抽象出来呢

59
00:02:18,200 --> 00:02:20,400
我们看这幅图呢我们知道

60
00:02:20,680 --> 00:02:22,600
它其实都有共同的特点

61
00:02:22,980 --> 00:02:25,460
就是它都是我们的宠物

62
00:02:25,860 --> 00:02:28,380
那我们第一步就是说找出它的种类

63
00:02:28,580 --> 00:02:30,590
种类它都是动物啊

64
00:02:30,590 --> 00:02:32,190
其次我们要找出它的属性

65
00:02:32,510 --> 00:02:33,990
最后我们要找出他的行为

66
00:02:35,600 --> 00:02:37,240
我们怎么去做呢

67
00:02:37,360 --> 00:02:38,600
我们第一步发现类

68
00:02:38,880 --> 00:02:41,180
比如说这里面有很多的小狗

69
00:02:41,420 --> 00:02:43,300
那每个狗呢它都是一个对象

70
00:02:43,660 --> 00:02:45,740
整体的这些对象组成了一个什么类

71
00:02:46,040 --> 00:02:47,560
这个类是叫什么叫狗类

72
00:02:48,320 --> 00:02:50,040
狗类里面有很多不同的狗

73
00:02:50,710 --> 00:02:52,790
根据这个对象呢我们抽象出类了

74
00:02:53,150 --> 00:02:55,710
所以说我们走完了第一步就是发钱类

75
00:02:57,210 --> 00:02:58,970
第二步呢我们是发现属性

76
00:02:59,130 --> 00:03:01,170
比如说狗有哪些属性呢

77
00:03:01,580 --> 00:03:02,700
它有一些共有的属性

78
00:03:02,700 --> 00:03:05,740
就比如说是品种年龄昵称健康情况

79
00:03:05,740 --> 00:03:07,380
包括跟主人的一些亲密度

80
00:03:07,860 --> 00:03:10,020
那只跟我们具体的业务

81
00:03:10,020 --> 00:03:11,100
相关的属性有哪些呢

82
00:03:11,100 --> 00:03:13,100
比如说我们需要知道它的名字

83
00:03:13,380 --> 00:03:14,540
需要知道他的健康值

84
00:03:14,540 --> 00:03:15,620
需要知道它的亲密度

85
00:03:15,860 --> 00:03:17,140
需要知道它的品种

86
00:03:17,480 --> 00:03:18,960
这些都是它的一个属性

87
00:03:20,740 --> 00:03:22,900
那第三步呢我们发现这个类的方法

88
00:03:22,900 --> 00:03:24,380
就是狗这个类有哪些方法呢

89
00:03:24,380 --> 00:03:26,620
他可能会去跑啊去废呀

90
00:03:26,940 --> 00:03:28,580
还去输出一些信息呀

91
00:03:29,160 --> 00:03:31,600
在这些东西里面我给他提供一个方法

92
00:03:31,600 --> 00:03:33,080
就是print方法就能够

93
00:03:33,400 --> 00:03:34,360
代表他的一些

94
00:03:34,720 --> 00:03:35,880
共有的一些行为

95
00:03:36,620 --> 00:03:38,860
通过这三个步骤呢其实我就能够

96
00:03:39,060 --> 00:03:40,500
抽象出狗这个类来

97
00:03:40,700 --> 00:03:42,140
这个方法其实就是类图

98
00:03:42,790 --> 00:03:43,550
大家可以看一下

99
00:03:44,110 --> 00:03:44,950
这个方框上面写

100
00:03:44,950 --> 00:03:46,510
了一个dogclass

101
00:03:46,510 --> 00:03:47,510
dog就是我们的类

102
00:03:47,810 --> 00:03:48,970
那下面写的这个name

103
00:03:49,050 --> 00:03:49,970
healthylover

104
00:03:49,970 --> 00:03:50,250
string

105
00:03:50,250 --> 00:03:52,610
就是我们刚才提出来的一些属性

106
00:03:52,830 --> 00:03:54,270
这个属性呢左边

107
00:03:54,390 --> 00:03:56,230
这个加号代表这个属性是公

108
00:03:56,390 --> 00:03:57,630
开可见的

109
00:03:57,930 --> 00:03:59,410
这个加号代表我们的

110
00:03:59,410 --> 00:04:00,930
访问修饰符是public

111
00:04:01,050 --> 00:04:01,810
公开可见

112
00:04:02,010 --> 00:04:04,730
那后面每一个英文单词就是属性

113
00:04:04,730 --> 00:04:05,890
后面有一个冒号

114
00:04:05,890 --> 00:04:07,250
冒号后面有一个string

115
00:04:07,370 --> 00:04:07,970
int等

116
00:04:07,970 --> 00:04:09,050
这些东西它是什么呢

117
00:04:09,250 --> 00:04:10,810
那代表我们现在这个属

118
00:04:10,810 --> 00:04:12,250
性的一个类型是什么

119
00:04:12,250 --> 00:04:13,770
比如说我们的名字就是

120
00:04:13,850 --> 00:04:14,610
string类型的

121
00:04:14,850 --> 00:04:16,769
那我们的健康值是int类型的

122
00:04:16,890 --> 00:04:18,570
那下面呢有一个横线

123
00:04:18,610 --> 00:04:20,050
横线下面有一个print

124
00:04:20,050 --> 00:04:22,290
这个print呢代表我们的方法

125
00:04:23,090 --> 00:04:25,010
通过这个三个步骤以后呢

126
00:04:25,010 --> 00:04:26,490
我们得到了一个狗类的清

127
00:04:26,490 --> 00:04:27,730
晰的一个设计的一个图

128
00:04:27,850 --> 00:04:28,690
就叫类图

129
00:04:29,190 --> 00:04:30,990
通过这个图更加容易

130
00:04:31,110 --> 00:04:32,830
直观去理解我们这个类

131
00:04:33,430 --> 00:04:35,350
大家可以看那个图啊很详细的啊

132
00:04:35,910 --> 00:04:37,070
类名类型

133
00:04:37,550 --> 00:04:40,350
属性名方法名等等等等我们都有啊

134
00:04:40,900 --> 00:04:42,140
后面这个word代表它的

135
00:04:42,140 --> 00:04:43,260
返回值类型是word

136
00:04:43,460 --> 00:04:44,500
是一个空的

137
00:04:46,760 --> 00:04:48,000
我们来看下对象初始化

138
00:04:48,560 --> 00:04:50,600
我们刚才第一步呢其实是通过对象

139
00:04:50,760 --> 00:04:51,920
出象出了类

140
00:04:52,470 --> 00:04:54,070
在知道有个类的情况下

141
00:04:54,070 --> 00:04:56,350
我们怎么样去获取这个对象呢

142
00:04:56,350 --> 00:04:56,870
我们就要

143
00:04:56,990 --> 00:04:59,230
利用这个对象初始化这个方法

144
00:04:59,480 --> 00:05:01,640
就是比如说我知道有企鹅这个类

145
00:05:01,880 --> 00:05:05,240
但是我要去实例化一个企鹅的对象

146
00:05:05,480 --> 00:05:07,480
哎就比如说我知道有人这个类

147
00:05:07,480 --> 00:05:09,600
但是我要把你去new出来

148
00:05:09,910 --> 00:05:12,310
这个时候通过这个new的方式啊

149
00:05:12,390 --> 00:05:14,590
new一个企鹅的一个构造方法

150
00:05:14,630 --> 00:05:17,820
就能够获得这个pgn1的这个企鹅

151
00:05:17,820 --> 00:05:19,980
啊这个是一个企鹅的对象

152
00:05:20,450 --> 00:05:21,690
这叫实例化对象

153
00:05:22,050 --> 00:05:22,810
那这个时候

154
00:05:23,090 --> 00:05:25,530
这个企鹅我们需要给它附一个名字

155
00:05:25,650 --> 00:05:27,930
比如说它需要有一个name叫qq

156
00:05:28,500 --> 00:05:30,420
他需要一个性别他是一个q仔

157
00:05:30,970 --> 00:05:33,410
那这一切呢都是通过这个构造方法

158
00:05:33,570 --> 00:05:34,050
和这个

159
00:05:34,250 --> 00:05:35,050
点nm的点

160
00:05:35,130 --> 00:05:36,690
sksex的方式去完成的

161
00:05:36,690 --> 00:05:37,570
但是我们能

162
00:05:37,610 --> 00:05:39,810
不能通过其他的方式去做呢

163
00:05:40,350 --> 00:05:41,550
我们同样可以在这个

164
00:05:41,750 --> 00:05:44,510
构造方法中去给它输入这个name

165
00:05:44,670 --> 00:05:46,470
livesexy等等一些东西

166
00:05:46,470 --> 00:05:47,710
去完成一些赋值

167
00:05:48,260 --> 00:05:50,540
就是说构造方法这里面的写完以后

168
00:05:50,990 --> 00:05:53,230
调用这个new构造方法以后

169
00:05:53,230 --> 00:05:54,750
我们就解决了这些问题

170
00:05:54,750 --> 00:05:57,270
就不要在下面每一个都是点去复制

171
00:05:59,820 --> 00:06:01,500
构造方法呢我们去抽象一下

172
00:06:01,500 --> 00:06:02,820
看一下他的一个形式

173
00:06:02,820 --> 00:06:05,740
它有访问修饰符构造方法名

174
00:06:06,180 --> 00:06:08,060
和括号组成

175
00:06:08,660 --> 00:06:09,820
看一下啊其实它跟我

176
00:06:09,820 --> 00:06:10,780
们普通方法的区别

177
00:06:10,780 --> 00:06:13,180
就是它没有返回值的类型

178
00:06:13,580 --> 00:06:15,380
并且他这个构造方法名呢

179
00:06:15,740 --> 00:06:18,420
是与我们的类名是相同的

180
00:06:19,740 --> 00:06:22,100
系统呢是默认提供一个无参构造

181
00:06:22,140 --> 00:06:23,340
其实我们可以在这里面

182
00:06:23,340 --> 00:06:24,460
输入一些参数的啊

183
00:06:26,150 --> 00:06:28,910
构造方法的重载也叫自定义构造号

184
00:06:28,910 --> 00:06:29,750
我们怎么去做呢

185
00:06:30,270 --> 00:06:31,710
当我们系统不再提供

186
00:06:31,990 --> 00:06:34,190
默认的无参构造方法的时候呢

187
00:06:34,470 --> 00:06:36,190
我们可以通过重载的方式

188
00:06:36,310 --> 00:06:38,070
去自定义一些构造方法

189
00:06:38,350 --> 00:06:40,230
比如说在下面这张图中

190
00:06:40,670 --> 00:06:41,790
我们通过输入

191
00:06:42,190 --> 00:06:42,990
namehealth

192
00:06:43,390 --> 00:06:44,790
lifesexy的方式

193
00:06:45,230 --> 00:06:47,590
对这些内容进行一些赋值

194
00:06:48,360 --> 00:06:49,720
我们看一下这个代码啊

195
00:06:49,720 --> 00:06:50,400
其实左边

196
00:06:50,440 --> 00:06:51,800
其实就是this点namem

197
00:06:51,800 --> 00:06:54,200
就是我们成员属性

198
00:06:54,960 --> 00:06:55,960
右边这个name就是我

199
00:06:55,960 --> 00:06:57,000
们传入的参数

200
00:06:57,240 --> 00:06:58,320
那这个this关键字呢

201
00:06:58,320 --> 00:07:00,680
就是说对一个对象的默认引用

202
00:07:00,680 --> 00:07:03,520
这里用区分这个同名的成员变量啊

203
00:07:03,810 --> 00:07:05,010
就比如说this点name

204
00:07:05,010 --> 00:07:06,010
就是我们的成员变量

205
00:07:06,010 --> 00:07:07,970
而后面的name就是我们局部参数

206
00:07:08,310 --> 00:07:09,870
那这个时候通过这个构造方法

207
00:07:09,870 --> 00:07:10,950
我就可以把那个name

208
00:07:10,990 --> 00:07:12,590
healthlive和sexy

209
00:07:12,800 --> 00:07:14,280
以入参的形式传入到

210
00:07:14,280 --> 00:07:15,200
我们的构造方法中

211
00:07:15,360 --> 00:07:16,760
赋给我们的成员变量

212
00:07:16,920 --> 00:07:18,000
这个时候我们的成员变量

213
00:07:18,320 --> 00:07:20,240
前面都给它进行修改了

214
00:07:20,670 --> 00:07:22,430
这个构造方法就特别的实用

215
00:07:22,990 --> 00:07:24,950
但是我们怎么样去做它

216
00:07:25,310 --> 00:07:27,430
我们就是通过重载的方式去做它

217
00:07:27,720 --> 00:07:30,000
系统会给我们提供一个相当于这样的

218
00:07:30,000 --> 00:07:31,760
无参的一个构造方法

219
00:07:32,430 --> 00:07:33,630
重载的定义叫什么呢

220
00:07:33,870 --> 00:07:35,030
唉我们来归纳一下啊

221
00:07:35,030 --> 00:07:36,710
就是方法名相同

222
00:07:36,710 --> 00:07:38,550
比如说这两个都是叫做什么

223
00:07:38,870 --> 00:07:41,150
p开头的一个企鹅的一个名称对吧

224
00:07:41,480 --> 00:07:42,920
它是跟类名相同的

225
00:07:42,960 --> 00:07:44,960
它是要构造方法是跟类名相同的

226
00:07:45,120 --> 00:07:46,720
所以它的方法名相同是重载

227
00:07:46,720 --> 00:07:47,560
第一个特点

228
00:07:47,760 --> 00:07:50,120
第二个就是参数的数据类型

229
00:07:50,420 --> 00:07:51,740
或参数个数不同

230
00:07:51,740 --> 00:07:54,100
比如说我们下面是有啊四个参数

231
00:07:54,530 --> 00:07:55,970
那我们上面是没有参数

232
00:07:55,970 --> 00:07:57,650
就是参数的个数不同对吧

233
00:07:57,930 --> 00:08:02,110
还有就是说与返回值访问修饰符无关

234
00:08:02,270 --> 00:08:03,470
哎我们这个地方其实

235
00:08:03,590 --> 00:08:05,590
构造方法是没有返回值的对吧

236
00:08:05,710 --> 00:08:06,910
所以说访问值无关

237
00:08:07,030 --> 00:08:08,590
访问修饰符呢也没有关系

238
00:08:08,590 --> 00:08:09,310
我们这个地方

239
00:08:09,650 --> 00:08:11,210
如果说要换成其他修饰符

240
00:08:11,450 --> 00:08:14,250
两者不一致也可以称为方法的重载

241
00:08:16,550 --> 00:08:18,310
然后我们来看一下方法重载调用啊

242
00:08:18,550 --> 00:08:20,950
比如说我们上来我们通过这个new

243
00:08:21,070 --> 00:08:21,990
企鹅的方式

244
00:08:22,180 --> 00:08:23,100
创造一个对象

245
00:08:23,140 --> 00:08:24,420
这个对象呢通过点

246
00:08:24,420 --> 00:08:25,740
print方式去调用

247
00:08:25,740 --> 00:08:27,380
它的共有的行为叫print

248
00:08:27,540 --> 00:08:28,140
打印出来

249
00:08:28,380 --> 00:08:30,500
然后我们也可以通过什么啊

250
00:08:30,730 --> 00:08:32,610
调用一个有参的构造方法

251
00:08:33,130 --> 00:08:34,890
哎有参的构造方法呢其实就是说

252
00:08:34,970 --> 00:08:35,890
调用这句话

253
00:08:36,049 --> 00:08:37,530
其实就是调用下面的内容

254
00:08:37,530 --> 00:08:39,780
就是把这个名字叫美美

255
00:08:40,299 --> 00:08:42,260
健康值亲密度和她的性别

256
00:08:42,340 --> 00:08:44,100
传入到我们的成员变量中

257
00:08:44,660 --> 00:08:46,060
那当然上面的无参构造

258
00:08:46,060 --> 00:08:47,380
就是说也可以这么写

259
00:08:47,980 --> 00:08:48,900
它的写法不同

260
00:08:48,900 --> 00:08:50,300
调用的方式是不同的

261
00:08:50,850 --> 00:08:52,770
其实就是说你这两个方法

262
00:08:52,770 --> 00:08:55,410
就是重载方法的入口是不一样的

263
00:08:55,410 --> 00:08:57,810
所以你最后里面的东西是不一样的

264
00:08:59,460 --> 00:09:03,420
阅读代码并输出运行结果指出原因

265
00:09:03,540 --> 00:09:04,620
大家看下这个代码啊

266
00:09:05,060 --> 00:09:06,140
这个代码呢就是说

267
00:09:06,590 --> 00:09:08,310
首先有个类叫企鹅类

268
00:09:08,670 --> 00:09:10,430
这个企鹅类里面它有一个昵称

269
00:09:10,430 --> 00:09:12,190
有一个健康值有一个性别

270
00:09:12,230 --> 00:09:14,830
并且有一个诶这是什么方法对吧

271
00:09:15,070 --> 00:09:17,190
然后最后有一个print方法对吧

272
00:09:17,340 --> 00:09:18,740
然后这上面是调用它

273
00:09:18,900 --> 00:09:20,940
通过new的方式去new了一个

274
00:09:21,180 --> 00:09:23,180
pgn3的一个企鹅对象

275
00:09:23,410 --> 00:09:24,490
然后通过这个对象

276
00:09:24,490 --> 00:09:25,690
呢去点print方法

277
00:09:26,050 --> 00:09:27,410
那最后这个结果是什么呢

278
00:09:27,570 --> 00:09:28,890
是什么原因导致这个结果

279
00:09:28,890 --> 00:09:30,250
大家去思考一下好吧

280
00:09:31,150 --> 00:09:33,670
诶这个结果呢是什么

281
00:09:33,910 --> 00:09:35,710
企鹅的名字是no

282
00:09:36,270 --> 00:09:38,950
健康值呢是零性别是none

283
00:09:39,190 --> 00:09:41,270
不对呀同学们看到不对呀对吧

284
00:09:41,850 --> 00:09:43,010
我是不是明明在一个地

285
00:09:43,010 --> 00:09:44,490
方把健康值定义为十

286
00:09:44,730 --> 00:09:46,690
性别定义为熊对吧

287
00:09:46,970 --> 00:09:48,850
那为什么我最后呢

288
00:09:49,400 --> 00:09:51,440
我的性别是n我的名字还是none

289
00:09:52,400 --> 00:09:53,680
我的健康值还是零呢

290
00:09:54,300 --> 00:09:55,700
是因为我们可能没有调

291
00:09:55,700 --> 00:09:56,700
用这个方法对不对

292
00:09:56,940 --> 00:09:58,260
哎为什么没有调用这个方法

293
00:09:58,260 --> 00:10:00,740
因为我们的构造方法呢其实它是一个

294
00:10:01,260 --> 00:10:02,660
无返回值类型

295
00:10:03,250 --> 00:10:04,130
那我们这个地方是

296
00:10:04,130 --> 00:10:05,570
有返回值类型word

297
00:10:05,570 --> 00:10:07,650
这个word能代表是我们这个方法

298
00:10:07,650 --> 00:10:08,850
就不是构造方法了

299
00:10:09,200 --> 00:10:10,120
那它就不会

300
00:10:10,160 --> 00:10:11,440
通过这个地方调用到我

301
00:10:11,440 --> 00:10:12,720
们这个红框这个地方

302
00:10:13,200 --> 00:10:14,040
所以我们的

303
00:10:14,560 --> 00:10:17,000
性别和我们的健康值都不对

304
00:10:18,480 --> 00:10:21,040
好这段代码大家也看一下啊

305
00:10:21,640 --> 00:10:22,840
哎我们的错误在哪呢

306
00:10:22,880 --> 00:10:24,000
比如说我们这个

307
00:10:24,480 --> 00:10:26,280
方法里面叫play这个方法

308
00:10:26,680 --> 00:10:27,520
这里面有一个

309
00:10:27,680 --> 00:10:29,840
intlockrintlock

310
00:10:29,840 --> 00:10:30,200
rain呢

311
00:10:30,200 --> 00:10:32,520
这个变量呢它是一个局部变量

312
00:10:32,600 --> 00:10:34,880
它是没有进行初始化的

313
00:10:35,410 --> 00:10:36,890
在我们实际编程敲的时候

314
00:10:36,890 --> 00:10:39,170
大家可以把代码敲到编译器里

315
00:10:39,250 --> 00:10:41,610
它会报错报什么错呢

316
00:10:42,150 --> 00:10:42,910
maynothave

317
00:10:43,070 --> 00:10:43,870
been初始化

318
00:10:44,070 --> 00:10:44,950
没有被初始化

319
00:10:45,310 --> 00:10:47,550
但是这是我们编译器里面

320
00:10:47,550 --> 00:10:48,670
可以显而易见的看到

321
00:10:48,670 --> 00:10:50,520
但是在我们的考试里面呢

322
00:10:50,520 --> 00:10:51,920
肯定是让我们自己去

323
00:10:52,100 --> 00:10:53,420
一些经验去看到的

324
00:10:53,500 --> 00:10:54,980
所以大家一定要注意这个东西

325
00:10:55,100 --> 00:10:56,260
一个是局部变量

326
00:10:56,260 --> 00:10:57,660
就是我们方法里面写的

327
00:10:57,660 --> 00:10:58,860
这些变量叫局部变量

328
00:10:59,020 --> 00:11:00,940
还有我们方法外面写的这些东西呢

329
00:11:00,940 --> 00:11:02,380
就是方法外面和类名

330
00:11:02,380 --> 00:11:03,220
下面写的这些东西

331
00:11:03,220 --> 00:11:05,500
叫做成员变量这个要区分清楚

332
00:11:07,140 --> 00:11:08,900
好我们来看一下stle关键字

333
00:11:09,460 --> 00:11:10,900
为什么会学习时代关键字呢

334
00:11:10,900 --> 00:11:12,060
我们想一下啊

335
00:11:12,480 --> 00:11:13,920
我们是不是可以通过类名

336
00:11:13,920 --> 00:11:15,040
直接访问成员变量呢

337
00:11:15,040 --> 00:11:16,720
因为我们刚才在写代码的过程中

338
00:11:16,720 --> 00:11:18,240
都是要首先new一个对象

339
00:11:18,240 --> 00:11:19,840
就是通过类new一个对象

340
00:11:19,840 --> 00:11:20,960
通过对象名呢

341
00:11:21,230 --> 00:11:23,310
点的方法去获取成员变量

342
00:11:23,510 --> 00:11:24,630
是不是要两个步骤

343
00:11:24,990 --> 00:11:25,950
我现在就想啊

344
00:11:25,950 --> 00:11:27,950
我直接通过类名点的方法去获取

345
00:11:28,350 --> 00:11:29,110
那怎么办呢

346
00:11:29,510 --> 00:11:31,150
通过set关键字是可以去

347
00:11:31,150 --> 00:11:32,310
实现这个功能的啊

348
00:11:32,900 --> 00:11:34,420
之前的一个方式就是说

349
00:11:34,420 --> 00:11:36,260
直接先new后点sexy

350
00:11:36,260 --> 00:11:37,380
就是说两个步骤

351
00:11:37,980 --> 00:11:39,940
我们通过stc关键字来定义变量

352
00:11:39,940 --> 00:11:40,660
就是比如说

353
00:11:40,780 --> 00:11:41,900
staticfinal

354
00:11:42,100 --> 00:11:42,460
string

355
00:11:42,740 --> 00:11:43,820
这个东西叫q仔

356
00:11:44,600 --> 00:11:45,680
其实这个地方还有一

357
00:11:45,680 --> 00:11:47,440
个修饰词叫做final

358
00:11:48,000 --> 00:11:50,040
用final修饰的变量称为常量

359
00:11:50,160 --> 00:11:51,320
其值是固定不变的

360
00:11:51,720 --> 00:11:54,000
所以说我们把这个常量的名字呢

361
00:11:54,000 --> 00:11:55,880
用这个大写的字母去表示

362
00:11:56,410 --> 00:11:58,170
这个时候这样写完以后呢

363
00:11:58,730 --> 00:11:59,970
我们就可以直接通过什

364
00:11:59,970 --> 00:12:01,210
么类名调用的方式

365
00:12:01,450 --> 00:12:04,330
通过类名点的方式去获取这个性别

366
00:12:05,050 --> 00:12:07,050
static我们可以定义方法

367
00:12:07,050 --> 00:12:08,330
就是staticword

368
00:12:08,450 --> 00:12:08,890
printer

369
00:12:09,330 --> 00:12:11,570
我们就可以用这个类名点这个方法

370
00:12:11,770 --> 00:12:12,450
去调用

371
00:12:14,180 --> 00:12:15,740
我们来看一下这个static呢

372
00:12:15,900 --> 00:12:17,340
修饰与非static修饰

373
00:12:17,340 --> 00:12:18,100
的一个区别

374
00:12:18,100 --> 00:12:18,540
好吧

375
00:12:19,190 --> 00:12:20,390
static非

376
00:12:20,790 --> 00:12:21,950
private的一个修饰呢

377
00:12:22,270 --> 00:12:23,430
它修饰在属性上面

378
00:12:23,430 --> 00:12:24,910
就是类属性和类变量

379
00:12:25,680 --> 00:12:26,080
那face

380
00:12:26,120 --> 00:12:27,680
staticprivate修饰呢

381
00:12:27,680 --> 00:12:29,280
就是修饰在这个属性上面

382
00:12:29,280 --> 00:12:30,960
就是实例属性实例变量

383
00:12:31,490 --> 00:12:32,490
这个非常重要

384
00:12:32,570 --> 00:12:33,610
大家一定要仔细听啊

385
00:12:33,610 --> 00:12:34,650
这个东西大家敲黑板

386
00:12:35,130 --> 00:12:37,290
考试中可能会有选择题或者是

387
00:12:37,370 --> 00:12:39,050
填空题的这个方式出现

388
00:12:39,710 --> 00:12:42,350
方法呢就是如果说修饰在方法上面

389
00:12:42,350 --> 00:12:43,350
我们就是类方法

390
00:12:43,790 --> 00:12:44,830
如果是facestatic就

391
00:12:44,830 --> 00:12:45,790
是实例方法

392
00:12:46,220 --> 00:12:47,220
那调用方式呢

393
00:12:47,460 --> 00:12:48,660
唉大家刚才讲了啊

394
00:12:48,990 --> 00:12:51,630
我可以通过类名点属性类名点方法

395
00:12:51,950 --> 00:12:54,030
对象点属性对象点方法四种

396
00:12:54,190 --> 00:12:55,630
方式去调用它

397
00:12:56,240 --> 00:12:58,440
而我们facestatic修饰呢

398
00:12:58,440 --> 00:13:00,840
我们只能通过对象点属性对象点方法

399
00:13:00,880 --> 00:13:01,880
方式去调用

400
00:13:02,210 --> 00:13:04,290
所以说我们通过static是不是

401
00:13:04,530 --> 00:13:06,490
大大方便了我们的调用呢

402
00:13:06,930 --> 00:13:08,610
那这个归属呢它是属于类的

403
00:13:08,930 --> 00:13:11,010
而这边的方法和属性呢

404
00:13:11,010 --> 00:13:13,290
还是归属于两个对象啊

405
00:13:13,370 --> 00:13:15,210
所以他的级别是不一样的啊

406
00:13:15,610 --> 00:13:17,010
大家一定要注意这个区分

407
00:13:18,680 --> 00:13:20,720
那static代码阅读请指出这

408
00:13:20,720 --> 00:13:22,000
个下面的一些错误

409
00:13:22,750 --> 00:13:24,350
我们刚才的错误是什么

410
00:13:24,350 --> 00:13:26,550
这个local是没有初始化的对吧

411
00:13:26,990 --> 00:13:28,350
现在我们给它初始化了

412
00:13:29,030 --> 00:13:31,070
这个地方呢其实在实例方法里面

413
00:13:31,070 --> 00:13:33,150
是不可以定义static变量的

414
00:13:33,270 --> 00:13:34,990
那我们如果写到编辑器里面

415
00:13:34,990 --> 00:13:36,110
它直接就会报错了

416
00:13:36,110 --> 00:13:37,320
啊这个地方是

417
00:13:37,720 --> 00:13:38,040
only

418
00:13:38,320 --> 00:13:39,680
finalispermeter

419
00:13:40,280 --> 00:13:40,960
这个地方只能

420
00:13:40,960 --> 00:13:42,440
写一个finalstatic

421
00:13:42,440 --> 00:13:43,680
是不能写在这里面的

422
00:13:43,960 --> 00:13:45,360
因为static提升到类级

423
00:13:45,360 --> 00:13:46,240
别了你在这个

424
00:13:46,400 --> 00:13:47,760
实例方法中是不能写的

425
00:13:47,760 --> 00:13:48,760
而不是实力级别

426
00:13:49,120 --> 00:13:50,880
我们应该有一个更加清晰的认识

427
00:13:52,660 --> 00:13:54,300
说完刚才这些地方以后呢

428
00:13:54,300 --> 00:13:56,900
我们来讲一下为什么要使用封装

429
00:13:57,300 --> 00:13:59,460
我们看一下下面这个代码有什么缺陷

430
00:13:59,460 --> 00:14:00,300
我们就能理解

431
00:14:00,300 --> 00:14:02,980
我们为什么要去学这个封装了啊

432
00:14:03,410 --> 00:14:04,530
这代码就是dog

433
00:14:04,650 --> 00:14:05,810
d等于newdog

434
00:14:05,810 --> 00:14:07,610
然后d点health等于1000

435
00:14:08,210 --> 00:14:09,010
这个属性

436
00:14:09,050 --> 00:14:10,490
值是不是通过这个d点

437
00:14:10,490 --> 00:14:11,770
health的方式去访问呢

438
00:14:12,300 --> 00:14:14,100
这个属性呢我们是可以

439
00:14:14,100 --> 00:14:15,620
是不是可以随意访问的呀

440
00:14:15,880 --> 00:14:17,200
你只要过来给我new一下

441
00:14:17,200 --> 00:14:18,360
new完以后我就可以复制

442
00:14:18,360 --> 00:14:19,360
这样就有问题了

443
00:14:19,480 --> 00:14:21,760
那如何解决上面的一些缺陷呢

444
00:14:21,760 --> 00:14:23,040
我们就使用封装

445
00:14:24,340 --> 00:14:25,660
我们来看一下什么是封装

446
00:14:26,460 --> 00:14:29,460
封装是面向对象的三大特征之一

447
00:14:30,060 --> 00:14:33,020
封装的概念是将类的某些信息

448
00:14:33,620 --> 00:14:36,220
隐藏在类的内部

449
00:14:36,590 --> 00:14:39,110
不允许外部程序直接访问

450
00:14:39,430 --> 00:14:40,030
而是通过

451
00:14:40,070 --> 00:14:43,390
该类提供的方法来实现对隐藏信息的

452
00:14:43,630 --> 00:14:44,830
操作和访问

453
00:14:45,320 --> 00:14:46,440
也就是下面这个图

454
00:14:46,920 --> 00:14:48,520
小孩在这个屋子里

455
00:14:48,800 --> 00:14:50,360
正常人是接触不到他的

456
00:14:50,600 --> 00:14:51,880
但是你要想接触它呢

457
00:14:51,880 --> 00:14:54,280
你必须要通过他给你提供的一个

458
00:14:54,640 --> 00:14:55,440
小窗户啊

459
00:14:56,430 --> 00:14:58,670
使用封装它有什么好处呢

460
00:14:59,060 --> 00:15:03,220
首先它只能通过规定的方法访问数据

461
00:15:03,220 --> 00:15:05,380
你只能通过它提供的一个入口

462
00:15:05,500 --> 00:15:07,220
比如说窗户才能进去

463
00:15:07,840 --> 00:15:09,600
方便修改实现

464
00:15:10,480 --> 00:15:12,320
方便加入一些控制语句

465
00:15:12,980 --> 00:15:14,060
还有一点就是说

466
00:15:14,180 --> 00:15:16,180
隐藏类的细节信息

467
00:15:16,180 --> 00:15:17,220
这个也很容易理解

468
00:15:17,220 --> 00:15:18,420
这个就是说我们把

469
00:15:18,880 --> 00:15:21,400
整个细节信息给它包裹住不让你看到

470
00:15:21,840 --> 00:15:23,240
那这些大家可能要记一下

471
00:15:23,520 --> 00:15:26,000
因为这些东西可能在我们的选择填空

472
00:15:26,330 --> 00:15:27,610
判断题中可能会出现

473
00:15:29,410 --> 00:15:30,650
如何去使用封装呢

474
00:15:31,190 --> 00:15:31,790
第一步呢

475
00:15:31,910 --> 00:15:33,870
就是把我们的属性的可见性呢

476
00:15:33,910 --> 00:15:35,030
修改为private

477
00:15:35,630 --> 00:15:37,630
第二步就是创建公有的get

478
00:15:37,790 --> 00:15:38,590
set方法

479
00:15:39,010 --> 00:15:40,330
用于属性的读写

480
00:15:41,100 --> 00:15:42,220
第三步就是在get

481
00:15:42,260 --> 00:15:44,460
set方法中加入属性的控制语句

482
00:15:44,780 --> 00:15:46,820
对属性值的合法性进行判断

483
00:15:47,500 --> 00:15:48,580
比如说我们前面

484
00:15:49,210 --> 00:15:50,530
随意就可以访问

485
00:15:50,770 --> 00:15:51,650
dog的health

486
00:15:52,010 --> 00:15:53,370
并且对health进行赋值

487
00:15:53,370 --> 00:15:54,530
赋一个错误的就1000

488
00:15:55,140 --> 00:15:56,020
这个时候我

489
00:15:56,420 --> 00:15:59,060
通过加入一些合法的判断以后

490
00:15:59,060 --> 00:16:00,580
他就不能够随意复制了

491
00:16:01,140 --> 00:16:02,380
那所以这个地方就解决

492
00:16:02,380 --> 00:16:03,460
了之前的一个代码

493
00:16:03,700 --> 00:16:05,420
一个问题啊

494
00:16:06,420 --> 00:16:07,820
我们来阅读一下这个代码啊

495
00:16:08,140 --> 00:16:08,660
首先呢

496
00:16:09,020 --> 00:16:12,100
哎这个dog他的一个属性有哪些呢

497
00:16:12,300 --> 00:16:13,460
nameelselove

498
00:16:13,700 --> 00:16:14,340
string对吧

499
00:16:14,500 --> 00:16:15,700
这些东西都是我们

500
00:16:16,110 --> 00:16:17,670
共有的这个狗的一些属性

501
00:16:17,670 --> 00:16:18,190
我们给他

502
00:16:18,390 --> 00:16:19,350
把前面的修饰符

503
00:16:19,350 --> 00:16:20,630
全部设置成private

504
00:16:20,630 --> 00:16:21,310
私有的属性

505
00:16:21,510 --> 00:16:22,150
那这样呢

506
00:16:22,430 --> 00:16:24,630
外面的人就没有办法直接去访问他

507
00:16:25,150 --> 00:16:26,150
那怎么样去访问它呢

508
00:16:26,150 --> 00:16:27,470
我要给他提供一个路径啊

509
00:16:27,990 --> 00:16:28,750
那怎么办呢

510
00:16:29,260 --> 00:16:31,140
设置一些get方法和set方法

511
00:16:31,140 --> 00:16:31,700
比如说get

512
00:16:31,780 --> 00:16:33,220
healthy就是能够获取

513
00:16:33,220 --> 00:16:34,020
我们的健康值

514
00:16:34,340 --> 00:16:36,020
那通过调用这个方法以后呢

515
00:16:36,160 --> 00:16:37,720
他就能够得到我们内部

516
00:16:37,720 --> 00:16:39,240
的health这个信息对吧

517
00:16:39,240 --> 00:16:41,240
这就是我提供给他的一个方法

518
00:16:41,560 --> 00:16:43,080
那我要去修改这个healthy呢

519
00:16:43,080 --> 00:16:45,400
我就要使用这个set方法

520
00:16:45,820 --> 00:16:46,900
那使用set方法比如

521
00:16:46,900 --> 00:16:48,140
说我传入个healthy

522
00:16:48,140 --> 00:16:49,780
然后对这个healthy进行赋值

523
00:16:50,880 --> 00:16:54,240
当然在复制前我是给他一个判断语句

524
00:16:54,790 --> 00:16:55,830
比如说我的healthy

525
00:16:55,830 --> 00:16:56,550
是大于100

526
00:16:56,550 --> 00:16:57,670
小于零这个区间内的

527
00:16:57,790 --> 00:16:59,550
我就不能够对它进行复制

528
00:17:00,320 --> 00:17:02,960
那这就是我们对它进行了一个控制

529
00:17:03,440 --> 00:17:05,720
大家听明白这个举例子以后就能够

530
00:17:05,920 --> 00:17:07,920
明白我们封装做的事情

531
00:17:08,510 --> 00:17:10,190
好我们来看一下旁边的类图啊

532
00:17:10,190 --> 00:17:14,050
我们要善于去把这个类抽象成类图

533
00:17:14,369 --> 00:17:17,250
并且把类图呢转换成我们的编码啊

534
00:17:17,450 --> 00:17:18,810
我们要具备这个能力啊

535
00:17:18,810 --> 00:17:19,890
这是一个设计能力

536
00:17:20,460 --> 00:17:21,099
我们来看一下

537
00:17:21,369 --> 00:17:22,690
这个dog呢有哪些属性

538
00:17:23,050 --> 00:17:25,089
我们就类图里面就有哪些属性对吧

539
00:17:25,089 --> 00:17:26,730
前面都是私有的方法

540
00:17:26,730 --> 00:17:27,810
所以我们都把这个

541
00:17:28,010 --> 00:17:29,970
之前的加号呢变成了减号

542
00:17:30,190 --> 00:17:31,430
那后面就是我们这个

543
00:17:31,670 --> 00:17:33,290
属性的一个一个类型

544
00:17:33,410 --> 00:17:35,650
那下面呢就是我们的属性的一些方法

545
00:17:35,650 --> 00:17:37,170
比如说除了print以后呢

546
00:17:37,370 --> 00:17:39,450
我们也加入了一些getset方法

547
00:17:39,690 --> 00:17:42,050
那这些方法前面都是公开的一个属性

548
00:17:42,050 --> 00:17:43,770
所以说是加号

549
00:17:44,270 --> 00:17:46,110
后面就是它的一个返回值类型

550
00:17:46,900 --> 00:17:48,220
大家通过这代码就能够

551
00:17:48,220 --> 00:17:49,500
对我们封装的概念

552
00:17:49,820 --> 00:17:51,100
得到进一步的一个理解

553
00:17:51,620 --> 00:17:53,140
第一步第二步第三步

554
00:17:53,940 --> 00:17:55,940
那我们看一下啊像这个this呢

555
00:17:55,940 --> 00:17:57,340
我们刚才老师也说过了啊

556
00:17:57,460 --> 00:17:58,020
这个this

557
00:17:58,180 --> 00:17:59,900
点health就代表我们的成员

558
00:18:00,540 --> 00:18:01,700
这个health指的就是

559
00:18:01,700 --> 00:18:02,300
我们的一个

560
00:18:02,700 --> 00:18:03,780
传入进来的入参

561
00:18:04,250 --> 00:18:05,610
在我们的编译器里面

562
00:18:05,610 --> 00:18:07,530
我们可以通过一些快捷键的方式去

563
00:18:07,730 --> 00:18:09,530
自动生成我们的getset方法

564
00:18:11,560 --> 00:18:12,640
我们来看一看this

565
00:18:12,680 --> 00:18:13,800
这个关键字的使用啊

566
00:18:14,280 --> 00:18:15,800
我们通过this点health

567
00:18:15,880 --> 00:18:17,080
来调用一个属性

568
00:18:17,550 --> 00:18:19,190
通过this点name来调用一个

569
00:18:19,270 --> 00:18:19,630
名字

570
00:18:20,350 --> 00:18:21,630
调用方法就是通过this

571
00:18:21,710 --> 00:18:22,750
点print方式

572
00:18:23,000 --> 00:18:24,440
还调用构造方法就是this

573
00:18:24,800 --> 00:18:27,240
这是无参构造还调用有参构造

574
00:18:27,240 --> 00:18:27,800
那就是this

575
00:18:28,160 --> 00:18:29,840
括号里面传入了一些参数

576
00:18:30,290 --> 00:18:31,890
我们来看一下如果要使用的话

577
00:18:32,370 --> 00:18:34,330
必须是构造方法中的第一条语句

578
00:18:36,150 --> 00:18:38,150
学习的东西呢我们进行了一个总结

579
00:18:38,740 --> 00:18:41,140
我们抽象和封装这一节里面东西呢

580
00:18:41,140 --> 00:18:42,340
我们主要是讲了一些

581
00:18:42,620 --> 00:18:45,140
面向对象的思想的开发程序的好处

582
00:18:45,730 --> 00:18:48,410
然后呢从现实世界中抽象出类

583
00:18:48,790 --> 00:18:50,710
使用这个现实世界抽象数类呢

584
00:18:50,710 --> 00:18:52,710
首先是找出名词确定类的属性

585
00:18:53,030 --> 00:18:55,950
其次呢是找出动词的确定方法

586
00:18:56,260 --> 00:18:58,460
剔除与业务般的属性和方法

587
00:18:58,870 --> 00:19:00,390
那方法重载有哪些呢

588
00:19:00,390 --> 00:19:02,190
方法重载我们刚才也说了啊

589
00:19:02,190 --> 00:19:03,270
有参构造无参构造

590
00:19:03,270 --> 00:19:05,710
它可能是区别就是参数项不同

591
00:19:05,950 --> 00:19:07,630
还有就是方法名是相同的

592
00:19:07,870 --> 00:19:10,830
与访问的修饰符和返回值无关

593
00:19:11,400 --> 00:19:13,000
那static呢是可以干什么

594
00:19:13,000 --> 00:19:15,360
可以修饰属性方法静态块

595
00:19:15,600 --> 00:19:17,600
static使用以后我们就可以

596
00:19:17,890 --> 00:19:18,650
通过类名

597
00:19:18,770 --> 00:19:21,250
点属性类名点方法的形式进行访问

598
00:19:21,970 --> 00:19:23,490
最后是我们的封装的步骤

599
00:19:23,730 --> 00:19:25,010
我们怎么去使用封装呢

600
00:19:25,010 --> 00:19:27,210
首先我们要修改属性的可见值

601
00:19:27,450 --> 00:19:29,170
把属性的可见值通过public

602
00:19:29,400 --> 00:19:30,360
修改成private

603
00:19:30,560 --> 00:19:31,840
这样我们的其他

604
00:19:32,120 --> 00:19:34,360
对象呢就无法去随意去访问它

605
00:19:34,700 --> 00:19:36,340
最后呢创建一个

606
00:19:36,460 --> 00:19:37,780
getset方法让别人能

607
00:19:37,780 --> 00:19:38,820
够去访问对吧

608
00:19:38,860 --> 00:19:40,540
那访问的过程中是需要加

609
00:19:40,540 --> 00:19:42,100
入一些属性的控制语句

610
00:19:42,600 --> 00:19:44,080
比如说你不满足我的条件

611
00:19:44,240 --> 00:19:46,040
你随便赋值我是不让你付的

612
00:19:46,200 --> 00:19:48,160
这样就能够提升程序的安全性

613
00:19:49,730 --> 00:19:50,450
看一下例题

614
00:19:50,850 --> 00:19:52,770
根据以下信息呢设计宠物类

615
00:19:53,310 --> 00:19:55,630
类型有狗啊狗有哪些东西啊

616
00:19:55,790 --> 00:19:58,110
哪些行为啊企鹅有哪些属性啊

617
00:19:58,110 --> 00:19:58,750
哪些行为啊

618
00:19:58,750 --> 00:20:02,310
我们来设计一下类图bug和企鹅

619
00:20:02,840 --> 00:20:04,720
所有的属性呢它前面都是减号

620
00:20:04,800 --> 00:20:06,760
就代表我们给它设置成一个私有

621
00:20:06,960 --> 00:20:08,560
通过getset的方法去访问

622
00:20:08,560 --> 00:20:09,680
就是个封装的形式

623
00:20:10,000 --> 00:20:11,040
这是安全的形式

624
00:20:11,500 --> 00:20:13,100
那下面所以有getset方法

625
00:20:13,300 --> 00:20:15,220
这些方法前面都是一个公开的属性

626
00:20:15,220 --> 00:20:16,020
就是加号

627
00:20:16,460 --> 00:20:18,380
然后后面都是一个方法的返回值类型

628
00:20:18,380 --> 00:20:19,780
上面是一个属性的类型

629
00:20:20,180 --> 00:20:21,260
这就是我们类图

630
00:20:21,580 --> 00:20:24,060
那通过类图呢学习我们就能知道

631
00:20:24,420 --> 00:20:27,840
如何把一个代码抽象成一个图的形式

632
00:20:27,840 --> 00:20:28,880
这样方便我们对

633
00:20:29,000 --> 00:20:31,000
整个代码进行一个管理和维护

634
00:20:32,050 --> 00:20:33,530
而根据类图呢编写

635
00:20:33,690 --> 00:20:35,010
dog类呢和起源类

636
00:20:35,450 --> 00:20:37,530
添加默认的构造方法啊

637
00:20:38,130 --> 00:20:38,650
比如说

638
00:20:39,160 --> 00:20:41,120
哎我们狗类呢我们有哪些属性呢

639
00:20:41,120 --> 00:20:42,880
我们给它哎都列一下对吧

640
00:20:43,160 --> 00:20:45,440
还有哪些就是无参构造方法

641
00:20:45,440 --> 00:20:47,750
我们在里面加了啊有参构造方法

642
00:20:47,750 --> 00:20:49,070
我们这边也写了对不对

643
00:20:49,270 --> 00:20:50,470
然后有一些方法呀

644
00:20:50,470 --> 00:20:51,510
get方法set的方法

645
00:20:51,510 --> 00:20:51,990
包括一些

646
00:20:52,030 --> 00:20:54,590
他自己的属性的方法就是吃啊玩啊

647
00:20:54,670 --> 00:20:56,470
对吧这是set支持set

648
00:20:56,550 --> 00:20:57,470
支持set对吧

649
00:20:57,750 --> 00:20:58,510
还有包括

650
00:20:58,860 --> 00:20:59,940
等等的一些后面的一

651
00:20:59,940 --> 00:21:01,100
些方法print的方法

652
00:21:01,100 --> 00:21:02,580
那企鹅也是同样的啊这

653
00:21:02,580 --> 00:21:04,060
个我就不详细去讲

654
00:21:04,300 --> 00:21:05,860
这个其实非常简单对吧

655
00:21:07,630 --> 00:21:08,230
好第二题

656
00:21:08,630 --> 00:21:11,870
是类方法中可以直接调用对象变量吗

657
00:21:12,570 --> 00:21:13,370
不可以的啊

658
00:21:13,970 --> 00:21:15,290
因为静态方法在类加载

659
00:21:15,290 --> 00:21:16,570
的时候就需要初始化

660
00:21:16,570 --> 00:21:17,650
对象变量需要在

661
00:21:17,930 --> 00:21:20,650
新建对象new之后才能够使用

662
00:21:21,260 --> 00:21:23,340
第三题是以下关于java封

663
00:21:23,340 --> 00:21:24,900
装的描述中正确的是

664
00:21:25,540 --> 00:21:26,340
a对吧

665
00:21:26,970 --> 00:21:28,210
封装主要作用是

666
00:21:28,650 --> 00:21:31,650
在于对外隐藏内部的实现细节

667
00:21:31,650 --> 00:21:33,130
增加程序的安全性

668
00:21:33,530 --> 00:21:34,650
所以a是对的啊

669
00:21:36,220 --> 00:21:38,740
第四题这个代码段的一个结果是什么

670
00:21:38,740 --> 00:21:40,180
这是程序阅读题在我们

671
00:21:40,180 --> 00:21:41,500
考试中经常出现啊

672
00:21:42,200 --> 00:21:43,720
我们答案是自己编译出错

673
00:21:43,720 --> 00:21:44,640
为什么呢唉

674
00:21:44,640 --> 00:21:46,830
因为我们java的静态方法是不

675
00:21:46,830 --> 00:21:48,350
能够访问非静态变量的

676
00:21:48,430 --> 00:21:49,950
如果要做的话需要把前面

677
00:21:50,110 --> 00:21:50,870
加上steady

678
00:21:51,230 --> 00:21:53,030
答案才会是零不然就会错

679
00:21:53,590 --> 00:21:55,870
同样在static方法中是不能够

680
00:21:56,070 --> 00:21:57,350
访问非静态变量的

681
00:21:58,610 --> 00:21:59,370
创建程序

682
00:21:59,850 --> 00:22:01,050
其中定义两个类

683
00:22:01,130 --> 00:22:02,610
体会java的封装性

684
00:22:03,050 --> 00:22:05,970
account类有姓名余额密码

685
00:22:06,290 --> 00:22:07,210
如果不满足会

686
00:22:07,250 --> 00:22:09,370
给出提示信息并给出默认值

687
00:22:09,750 --> 00:22:11,270
然后通过set的方法

688
00:22:11,670 --> 00:22:13,310
给account的属性赋值

689
00:22:13,510 --> 00:22:15,270
最后在测试类中进行测试

690
00:22:15,550 --> 00:22:17,510
这个就是我们说的封装三步骤

691
00:22:17,830 --> 00:22:19,870
前面已经讲了很多这个例子了

692
00:22:19,910 --> 00:22:21,390
看一下实际的编码怎么去写

693
00:22:22,350 --> 00:22:24,190
我们首先定义account这个类

694
00:22:24,230 --> 00:22:25,550
把这个类里面有属性

695
00:22:26,020 --> 00:22:27,260
有哪些属性的名字

696
00:22:27,860 --> 00:22:29,260
余额和密码对吧

697
00:22:29,580 --> 00:22:31,260
然后通过有参构造的方式

698
00:22:31,740 --> 00:22:33,020
进行赋值对吧

699
00:22:33,340 --> 00:22:35,060
那赋值的时候呢我们要记得

700
00:22:35,060 --> 00:22:36,380
我们要给他getset方法

701
00:22:36,380 --> 00:22:36,820
为什么呢

702
00:22:36,820 --> 00:22:37,980
因为我们在属性的时

703
00:22:37,980 --> 00:22:39,340
候就已经把所有的

704
00:22:39,560 --> 00:22:41,680
类型设置成一个私有

705
00:22:41,840 --> 00:22:43,040
让它不能够访问了

706
00:22:43,120 --> 00:22:45,040
所以说我们要给他一个方法去访问

707
00:22:45,300 --> 00:22:47,220
比如说set方法的时候我们要判断

708
00:22:47,300 --> 00:22:49,340
我们不能随意让他去修改我们值

709
00:22:49,340 --> 00:22:51,500
只有满足我们的条件的时候

710
00:22:51,500 --> 00:22:52,940
我们才能够给他去修改

711
00:22:53,600 --> 00:22:56,240
然后最后呃下面密码也是同样的

712
00:22:56,240 --> 00:22:57,680
给他满足微信行业程序修改

713
00:22:57,760 --> 00:23:00,120
最后呢我们创建了一个测试类

714
00:23:00,690 --> 00:23:04,010
把我们这个对象进行一个什么实例化

715
00:23:04,370 --> 00:23:06,130
哎进行一个info打印一下

716
00:23:06,130 --> 00:23:07,770
就能把最后结果弄出来

717
00:23:08,250 --> 00:23:09,250
很简单一件事

718
00:23:09,760 --> 00:23:12,040
这个地方就是考验大家对封装的理解

719
00:23:12,040 --> 00:23:13,840
封装三个步骤老师再总结一下

720
00:23:14,080 --> 00:23:16,640
首先呢是把我们的成员属性

721
00:23:17,030 --> 00:23:18,630
的修饰符改成了private

722
00:23:18,710 --> 00:23:19,310
私有答案

723
00:23:19,310 --> 00:23:20,750
第二个步骤就是给出get

724
00:23:20,870 --> 00:23:21,510
set方法

725
00:23:21,990 --> 00:23:23,860
来让别人能够访问你

726
00:23:24,060 --> 00:23:25,420
第三个就是说在get

727
00:23:25,580 --> 00:23:27,980
set方法中你加入了一些控制语句

728
00:23:28,380 --> 00:23:30,620
控制别人访问你的一些方式

729
00:23:30,780 --> 00:23:32,540
这是非常重要的一个步骤

730
00:23:32,740 --> 00:23:34,980
那封装整体上就能够解决

731
00:23:34,980 --> 00:23:36,260
我们程序的一个安全

732
00:23:36,300 --> 00:23:37,180
漏洞的问题

733
00:23:38,640 --> 00:23:40,080
练习题呢大家可以课后看

734
00:23:40,080 --> 00:23:41,400
一下去做一下这个题目

735
00:23:42,980 --> 00:23:44,580
那本科结束谢谢大家
